{"componentChunkName":"component---src-templates-blog-page-markdown-index-js","path":"/blog/optimizing-website-performance-improve-seo-384b1f1b","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://techwaifu.com"}},"blog":{"html":"<p>Wondering why your website's SEO ranking is constantly changing? Google is constantly tweaking their algorithm to improve search quality. Some of Google's most notable changes include filtering out low quality sites, favoring mobile optimized sites, and down ranking sites that artificially increase inbound number of links. Google recently announced that <a href=\"https://www.theverge.com/2020/5/28/21272543/google-search-results-page-experience-load-time-contentfu-paint-layout-shift-top-stories-amp\">page experience will impact SEO rankings</a> as well. This <a href=\"https://web.dev/vitals/\">web.dev</a> goes into more detail on what contributes to a good \"page experience\" but the main theme is around performance and load times. Today, we'll be taking a look at the changes I made on my site to account for these changes.</p>\n<p>Google's algorithm is a blackbox so we don't know for sure what signals Google uses to rank your site, but three metrics Google will take into account include Largest Contentful Paint, First Input Delay, and Cumulative Layout Shift.</p>\n<h2>Site Speed as an SEO Signal</h2>\n<p>People don't like to wait in general. This applies to website load times as well. It has been proven that <a href=\"https://www.google.com/search?q=longer+load+times+bounce+rates&#x26;oq=longer+load+times+bounce+rates&#x26;aqs=chrome..69i57.2945j0j7&#x26;sourceid=chrome&#x26;ie=UTF-8\">longer load times contribute to higher bounce rates</a> too. Hence, Google wants to quantify site speed and favor sites withoptimal load times.</p>\n<h3><a href=\"https://web.dev/lcp/\">LCP (Largest Contentful Paint)</a></h3>\n<p>This metric is essentially how long it takes to paint what Google considers the main content on the page.</p>\n<p>For example, if you're loading up an article and the article has a title, an article image, and some text, Google might consider the most contentful item as the article image. Currently, Google only looks at <a href=\"https://web.dev/lcp/#what-elements-are-considered\">certain items on the page</a>.</p>\n<p>You can analyze your website on PageSpeed Insight to see what Google considers the \"contentful object\".</p>\n<h3><a href=\"https://web.dev/fid/\">FID (First Input Delay)</a></h3>\n<p>FID is the time it takes for your site to respond to the first click on the page.</p>\n<p>FID can be calculated by the time it takes between clicking on a link or a button until the browser starts to process that event.</p>\n<h3><a href=\"https://web.dev/cls/\">CLS (Cumulative Layout Shift)</a></h3>\n<p>This checks if the content on your page moves around after it has been loaded.</p>\n<p>Have you ever tried to click on something and then an ad pops up and you click on that instead? Google quantifies this with CLS.</p>\n<p>TLDR: Reduce load on the device and use placeholders to prevent CLS. This includes reducing how much time the device has to run Javascript, how much time to paint the page, and how much data the site has to fetch at once.</p>\n<p>To see how your site is performing right now, you can use <a href=\"https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Ftechwaifu.com%2F&#x26;tab=desktop\">Pagespeed Insights</a>. If your site has reasonable amount of traffic, it will also show metrics collected from real users. You can also find performance metrics in Chrome's devtools under the Lighthouse tab.</p>\n<p><img src=\"/blogImages/seo_performance/pagespeed_stats.jpg?width=1183&#x26;height=1181&#x26;isResponsive=true&#x26;supportsWebp=true\" alt=\"Pagespeed Insights\"></p>\n<p>Now we know what to improve on, let's see the change I personally made to improve my scores.</p>\n<h2>Lazy Loading Content with Long Paint Times</h2>\n<p>The first improvement I made was to lazy load content such as images, videos, and ads. The way lazy loading works is it defers the rendering and fetching of content until the user has scrolled to a certain threshold.</p>\n<p>There are a lot of lazy loading libraries out there, but I decided to build my own. The main idea is to listen to the window's scroll event and check if the user has scrolled to a certain threshold. Once the user has scrolled to that position, then we'll actually start fetching the content and rendering it on the page.</p>\n<pre><code>const componentOffsetTop = ref.current.offsetTop\nconst curYPosition = window.scrollY;\nconst offset = 500;\n\nif (componentOffsetTop &#x3C;= curYPosition + document.body.clientHeight + offset) {\n    // render the component\n}\n</code></pre>\n<p>Some browsers support lazy loading natively like Chrome. All you need to do is add <code>loading=\"lazy\"</code> to your img tag like so.</p>\n<pre><code>&#x3C;img src=\"image.png\" loading=\"lazy\" alt=\"…\" width=\"200\" height=\"200\">\n</code></pre>\n<p>However, because not every single browser supports it, I ended up implementing my own solution. For my first pass, I used the following code to lazy load my images. FYI, all of these examples will be in React because my site is written in React.</p>\n<pre><code>const LazyLoadImage = (props) => {\n    const ref = useRef(null);\n    const [state, setState] = useState({\n        loaded: false,\n        src: null,\n        shouldFetch: true,\n    });\n\n    const removeListeners = () => {\n        window.removeEventListener(\"scroll\", handleScroll);\n    };\n\n    const removeListenersCallback = useCallback(removeListeners);\n\n    const loadImage = useCallback (() => {\n        setState({\n            ...state,\n            src: props.src,\n            shouldFetch: false,\n            srcset: props.srcset,\n            shouldStartLazyLoadAnimation: true,\n        });\n        removeListenersCallback();\n    }, [state, removeListenersCallback, props]);\n\n    const shouldLoadImage = useCallback((componentOffsetTop, userYPosition) => {\n        return state.shouldFetch &#x26;&#x26;\n        !state.loaded &#x26;&#x26;\n        componentOffsetTop &#x3C;= userYPosition + document.body.clientHeight + 500; \n    }, [state]);\n\n    const onImageLoad = () => {\n        if (state.src === props.src) {\n            setState({\n                ...state,\n                loaded: true,\n            });\n        }\n    };\n\n    const handleScroll = useCallback(debounce(() => {\n        const yPosition = window.scrollY;\n        if (shouldLoadImage(ref.current.offsetTop, yPosition)) {\n            loadImage();\n        }\n    }, 100), [loadImage, shouldLoadImage]);\n\n    useEffect(() => {\n        const yPosition = window.scrollY;\n        // Handles initial mount to check if image is already within threshold without scrolling.\n        if (shouldLoadImage(ref.current.offsetTop, yPosition)) {\n            loadImage();\n        } else {\n            window.addEventListener('scroll', handleScroll);\n        }\n\n        return () => {\n            removeListenersCallback();\n        };\n    }, [shouldLoadImage, loadImage, handleScroll, removeListenersCallback]);\n\n    const { src } = state;\n    return (\n        &#x3C;img\n            ref={ref}\n            onLoad={onImageLoad}\n            className={props.className}\n            src={src}\n            alt={props.alt}\n            loading=\"lazy\"\n        />\n    );\n}\n</code></pre>\n<p>This Lazy Loading component defers process of fetching images and painting them onto the page, but this code will hurt your Cumulative Layout Shift. We'll look into how to fix that in the next section.</p>\n<h2>Using Placeholders Inside of Lazy Loading Containers</h2>\n<p>The main issue with the lazy loading component is that we don't know how much space the image will need to take up on the screen.</p>\n<p>One way to work around this is to ensure all images have the same dimensions for the same component. A common pattern is to either ensure all the images have the same resolution and aspect ratio or to crop the image to make sure it fits in a fixed container.</p>\n<p><img src=\"/blogImages/seo_performance/fixed_images.jpg?width=1554&#x26;height=927&#x26;isResponsive=true&#x26;supportsWebp=true\" alt=\"Cropped Image\"></p>\n<p>However, this doesn't work for all use-cases. For example, my blog has images with various aspect ratios and orientations. Some images are in landscape and some are in portrait. A common practice is to use the following CSS for responsive images.</p>\n<pre><code>img {\n    width: 100%;\n    height: auto;\n}\n</code></pre>\n<p>The issues with using height auto is that the browser doesn't know how much space to allocate until the image has been loaded. I got around this issue by adding some additional metadata to my images to preallocate the space without actually fetching the image. I added the expected width and height as a query parameter to the image.</p>\n<pre><code>/blogImages/chromebook_coding/cover-2.jpg?width=1742&#x26;height=1306\n</code></pre>\n<p><img src=\"/blogImages/seo_performance/preallocated_img.jpg?width=2334&#x26;height=1256&#x26;isResponsive=true&#x26;supportsWebp=true\" alt=\"Preallocated Image\"></p>\n<p>The query parameters contain both the width and height of the image so I know exactly how much space to allocate. Then in the Lazy Load Image component, I set the initial state of <code>src</code> with a placeholder svg using the width and height specified in the query params. This svg reserves the required space on the page before we fetch the image.</p>\n<pre><code>const placeholderSrc = (img) => {\n    const { width, height } = img;\n    return `data:image/svg+xml,%3Csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${width} ${height}\"%3E%3C/svg%3E`;\n};\n\n...\n\nconst [state, setState] = useState({\n    loaded: false,\n    src: placeholderSrc(props),\n    ...\n});\n</code></pre>\n<p>Now your Lazy Loaded image won't have any issues with shifted layouts!</p>\n<h2>Using Appropriate Image Size for Certain Device Dimensions</h2>\n<p>Lastly, I started added a srcset to my images. Essentially this tells the browser to use a different sized dimension based on its size. You can customize it such that when using a mobile device, it'll fetch a lower resolution image and a non mobile device will use a higher resolution image. On this site, each image has 6 variations: width of 240px, width of 320px, width of 480px, width of 720px, width of 960px, and the original image. I use the lower resolution photos when I expect the image won't exceed a certain size. For example, on the <a href=\"https://techwaifu.com/\">homepage of Techwaifu.com</a>, the images in the smaller article cards never exceed 300px, so I always use the <a href=\"http://techwaifu.com/blogImages/chromebook_coding/cover-2-320.jpg\">320px variation of the image</a>.</p>\n<p><img src=\"/blogImages/seo_performance/fixed_width_img.jpg?width=1919&#x26;height=800&#x26;isResponsive=true&#x26;supportsWebp=true\" alt=\"Fixed Width Image\"></p>\n<p>When comparing the original image versus a shrunken variation of the image, you'll notice the original one will always take longer to download and is much larger to download. This is great for improving your site's performance since you won't need to fetch and render a 3200x2400 image on your 375x812 device. </p>\n<p><img src=\"/blogImages/seo_performance/original_img.jpg?width=1286&#x26;height=1061&#x26;isResponsive=true&#x26;supportsWebp=true\" alt=\"Original Image\"></p>\n<p><img-caption><a href=\"https://techwaifu.com/blogImages/leica_cl/leica_summilux_tl_5.jpg\">Original Image</a> | 299kB | 94ms to Download</img-caption></p>\n<p><img src=\"/blogImages/seo_performance/shrunken_img.jpg?width=1289&#x26;height=1000&#x26;isResponsive=true&#x26;supportsWebp=true\" alt=\"Compressed Image\"></p>\n<p><img-caption><a href=\"https://techwaifu.com/blogImages/leica_cl/leica_summilux_tl_5-480.jpg\">Shrunken Image</a> | 52.9kB | 47ms to Download</img-caption></p>\n<p>Now let's take a look at how this is done in the code. If you inspect an image on <a href=\"https://techwaifu.com/recommended-chromebooks-for-programming-2020-5734ed1a\">Techwaifu's blog</a>, you'll notice there's two attributes on the image other than src: sizes and srcset. </p>\n<p>The sizes attribute determines which image from the srcset should be used. It's pretty flexible since you can change the image to fetch based on the device size using max-width. Take a look at this article on <a href=\"https://ericportis.com/posts/2014/srcset-sizes/%5D\">srcset and sizes</a> for an in-depth guide.</p>\n<pre><code>sizes=\"(max-width: 480px) 150px, 480px\"\n</code></pre>\n<p>The srcset contains all the different sized images with the width the image should be used at. </p>\n<pre><code>srcset=\"/blogImages/ml_images/cover-240.jpg 240w, /blogImages/ml_images/cover-320.jpg 320w, /blogImages/ml_images/cover-480.jpg 480w, /blogImages/ml_images/cover-720.jpg 720w, /blogImages/ml_images/cover-960.jpg 960w\"\n</code></pre>\n<p>Altogether, the image tag looks like this.</p>\n<pre><code>&#x3C;img src=\"/blogImages/ml_images/cover-240.jpg\" sizes=\"(max-width: 480px) 150px, 480px\" srcset=\"/blogImages/ml_images/cover-240.jpg 240w, /blogImages/ml_images/cover-320.jpg 320w, /blogImages/ml_images/cover-480.jpg 480w, /blogImages/ml_images/cover-720.jpg 720w, /blogImages/ml_images/cover-960.jpg 960w\">\n</code></pre>\n<p>It's pretty easy to generate all the various images using <a href=\"https://www.npmjs.com/package/sharp\">Sharp</a>. Sharp can be used to resize images and even generate a <a href=\"https://developers.google.com/speed/webp\">webp</a> variant. I used this code generate all the images at the different sizes. </p>\n<pre><code>const fs = require('fs');\nconst sharp = require('sharp');\nconst shell = require('shelljs');\n\nconst XXS_WIDTH = 240;\nconst XS_WIDTH = 320;\nconst S_WIDTH = 480;\nconst M_WIDTH = 720;\nconst L_WIDTH = 960;\n\nconst compressedSizes = [\n    XXS_WIDTH,\n    XS_WIDTH,\n    S_WIDTH,\n    M_WIDTH,\n    L_WIDTH,\n];\n\nfunction resizeImages(imagePath) {\n    compressedSizes.forEach(width => {\n        const outPath = \"out/\" + imagePath.substring(0, imagePath.lastIndexOf(\"/\"));\n        // Create the folders for the output\n        if (!fs.existsSync(outPath)) {\n            shell.mkdir('-p', outPath);\n        }\n\n        // Generates jpg images\n        const outPathWithSize = imagePath.substring(0, imagePath.indexOf(\".\")) + \"-\" + width;\n\n        sharp(imagePath, {\n            failOnError: false\n        })\n        .clone()\n        .resize({ width: width })\n        .toFile(\"out/\" + outPathWithSize + \".jpg\").catch(err => console.log(err));\n    });\n}   \n</code></pre>\n<p>I also needed to update my Lazy Load component so the image will accept the srcset.</p>\n<pre><code>const LazyLoadImage = (props) => {\n    const ref = useRef(null);\n    const [state, setState] = useState({\n        loaded: false,\n        src: placeholderSrc(props),\n        srcSet: null, \n        shouldFetch: true,\n    });\n\n    const removeListeners = () => {\n        window.removeEventListener(\"scroll\", handleScroll);\n    };\n\n    const removeListenersCallback = useCallback(removeListeners);\n\n    const loadImage = useCallback (() => {\n        setState({\n            ...state,\n            src: props.src,\n            shouldFetch: false,\n            srcset: props.srcset,\n        });\n        removeListenersCallback();\n    }, [state, removeListenersCallback, props]);\n\n    const shouldLoadImage = useCallback((componentOffsetTop, userYPosition) => {\n        return state.shouldFetch &#x26;&#x26;\n        !state.loaded &#x26;&#x26;\n        componentOffsetTop &#x3C;= userYPosition + document.body.clientHeight + 500; \n    }, [state]);\n\n    const onImageLoad = () => {\n        if (!state.loaded &#x26;&#x26; state.src === props.src) {\n            setState({\n                ...state,\n                loaded: true,\n            });\n        }\n    };\n\n    const onError = () => {\n        setState({\n            ...state,\n            loaded: true\n        });\n        removeListeners();\n    };\n\n    const handleScroll = useCallback(debounce(() => {\n        const yPosition = window.scrollY;\n        if (shouldLoadImage(ref.current.offsetTop, yPosition)) {\n            loadImage();\n        }\n    }, 100), [loadImage, shouldLoadImage]);\n\n    useEffect(() => {\n        const yPosition = window.scrollY;\n        // Handles initial mount to check if image is already within threshold without scrolling.\n        if (shouldLoadImage(ref.current.offsetTop, yPosition)) {\n            loadImage();\n        } else {\n            window.addEventListener('scroll', handleScroll);\n        }\n\n        return () => {\n            removeListenersCallback();\n        };\n    }, [shouldLoadImage, loadImage, handleScroll, removeListenersCallback]);\n\n    const { loaded, src, srcset  } = state;\n    const { sizes } = props;\n    return (\n        &#x3C;img\n            ref={ref}\n            onLoad={onImageLoad}\n            onError={onError}\n            className={props.className}\n            src={src}\n            srcSet={srcset}\n            sizes={sizes}\n            alt={props.alt}\n            loading=\"lazy\"\n        />\n    );\n}\n</code></pre>\n<p>Congrats! Now you have a Lazy Loaded Image that supports different sized images using srcset.</p>\n<h2>Conclusion</h2>\n<p>I primarily worked on optimizing the images on my site because images are usually the largest contentful item on each blog post. Using this lazy loaded component with the placeholder helped reduce my CLS from > 0.10 to 0. Lazy loading also reduced the initial render since the browser didn't have to paint all the images at once. Using srcsets also optimized how large each network request as well. I would recommend recommend looking at <a href=\"https://web.dev/vitals/\">web.dev</a> to see their recommendations for improving site performance as well. Be sure to track your site's performance over time using <a href=\"https://developers.google.com/speed/pagespeed/insights/\">PageSpeed Insights</a>. Every time I made a change, I verified the before and after performance on that site to verify it really is an improvement. What changes have you made to your site to account for Google's algorithm change? Let me know in the comments section below and check out <a href=\"https://techwaifu.com/recommended-chromebooks-for-programming-2020-5734ed1a\">The Best Chromebooks for Programming in 2020</a> to find your next laptop.</p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Wondering why your website's SEO ranking is constantly changing? Google is constantly tweaking their algorithm to improve search quality. Some of Google's most notable changes include filtering out low quality sites, favoring mobile optimized sites, and down ranking sites that artificially increase inbound number of links. Google recently announced that "},{"type":"element","tagName":"a","properties":{"href":"https://www.theverge.com/2020/5/28/21272543/google-search-results-page-experience-load-time-contentfu-paint-layout-shift-top-stories-amp"},"children":[{"type":"text","value":"page experience will impact SEO rankings"}]},{"type":"text","value":" as well. This "},{"type":"element","tagName":"a","properties":{"href":"https://web.dev/vitals/"},"children":[{"type":"text","value":"web.dev"}]},{"type":"text","value":" goes into more detail on what contributes to a good \"page experience\" but the main theme is around performance and load times. Today, we'll be taking a look at the changes I made on my site to account for these changes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Google's algorithm is a blackbox so we don't know for sure what signals Google uses to rank your site, but three metrics Google will take into account include Largest Contentful Paint, First Input Delay, and Cumulative Layout Shift."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Site Speed as an SEO Signal"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"People don't like to wait in general. This applies to website load times as well. It has been proven that "},{"type":"element","tagName":"a","properties":{"href":"https://www.google.com/search?q=longer+load+times+bounce+rates&oq=longer+load+times+bounce+rates&aqs=chrome..69i57.2945j0j7&sourceid=chrome&ie=UTF-8"},"children":[{"type":"text","value":"longer load times contribute to higher bounce rates"}]},{"type":"text","value":" too. Hence, Google wants to quantify site speed and favor sites withoptimal load times."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://web.dev/lcp/"},"children":[{"type":"text","value":"LCP (Largest Contentful Paint)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This metric is essentially how long it takes to paint what Google considers the main content on the page."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For example, if you're loading up an article and the article has a title, an article image, and some text, Google might consider the most contentful item as the article image. Currently, Google only looks at "},{"type":"element","tagName":"a","properties":{"href":"https://web.dev/lcp/#what-elements-are-considered"},"children":[{"type":"text","value":"certain items on the page"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"You can analyze your website on PageSpeed Insight to see what Google considers the \"contentful object\"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://web.dev/fid/"},"children":[{"type":"text","value":"FID (First Input Delay)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"FID is the time it takes for your site to respond to the first click on the page."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"FID can be calculated by the time it takes between clicking on a link or a button until the browser starts to process that event."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://web.dev/cls/"},"children":[{"type":"text","value":"CLS (Cumulative Layout Shift)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This checks if the content on your page moves around after it has been loaded."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Have you ever tried to click on something and then an ad pops up and you click on that instead? Google quantifies this with CLS."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"TLDR: Reduce load on the device and use placeholders to prevent CLS. This includes reducing how much time the device has to run Javascript, how much time to paint the page, and how much data the site has to fetch at once."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To see how your site is performing right now, you can use "},{"type":"element","tagName":"a","properties":{"href":"https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Ftechwaifu.com%2F&tab=desktop"},"children":[{"type":"text","value":"Pagespeed Insights"}]},{"type":"text","value":". If your site has reasonable amount of traffic, it will also show metrics collected from real users. You can also find performance metrics in Chrome's devtools under the Lighthouse tab."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/blogImages/seo_performance/pagespeed_stats.jpg?width=1183&height=1181&isResponsive=true&supportsWebp=true","alt":"Pagespeed Insights"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now we know what to improve on, let's see the change I personally made to improve my scores."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Lazy Loading Content with Long Paint Times"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The first improvement I made was to lazy load content such as images, videos, and ads. The way lazy loading works is it defers the rendering and fetching of content until the user has scrolled to a certain threshold."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There are a lot of lazy loading libraries out there, but I decided to build my own. The main idea is to listen to the window's scroll event and check if the user has scrolled to a certain threshold. Once the user has scrolled to that position, then we'll actually start fetching the content and rendering it on the page."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"const componentOffsetTop = ref.current.offsetTop\nconst curYPosition = window.scrollY;\nconst offset = 500;\n\nif (componentOffsetTop <= curYPosition + document.body.clientHeight + offset) {\n    // render the component\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Some browsers support lazy loading natively like Chrome. All you need to do is add "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"loading=\"lazy\""}]},{"type":"text","value":" to your img tag like so."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"<img src=\"image.png\" loading=\"lazy\" alt=\"…\" width=\"200\" height=\"200\">\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"However, because not every single browser supports it, I ended up implementing my own solution. For my first pass, I used the following code to lazy load my images. FYI, all of these examples will be in React because my site is written in React."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"const LazyLoadImage = (props) => {\n    const ref = useRef(null);\n    const [state, setState] = useState({\n        loaded: false,\n        src: null,\n        shouldFetch: true,\n    });\n\n    const removeListeners = () => {\n        window.removeEventListener(\"scroll\", handleScroll);\n    };\n\n    const removeListenersCallback = useCallback(removeListeners);\n\n    const loadImage = useCallback (() => {\n        setState({\n            ...state,\n            src: props.src,\n            shouldFetch: false,\n            srcset: props.srcset,\n            shouldStartLazyLoadAnimation: true,\n        });\n        removeListenersCallback();\n    }, [state, removeListenersCallback, props]);\n\n    const shouldLoadImage = useCallback((componentOffsetTop, userYPosition) => {\n        return state.shouldFetch &&\n        !state.loaded &&\n        componentOffsetTop <= userYPosition + document.body.clientHeight + 500; \n    }, [state]);\n\n    const onImageLoad = () => {\n        if (state.src === props.src) {\n            setState({\n                ...state,\n                loaded: true,\n            });\n        }\n    };\n\n    const handleScroll = useCallback(debounce(() => {\n        const yPosition = window.scrollY;\n        if (shouldLoadImage(ref.current.offsetTop, yPosition)) {\n            loadImage();\n        }\n    }, 100), [loadImage, shouldLoadImage]);\n\n    useEffect(() => {\n        const yPosition = window.scrollY;\n        // Handles initial mount to check if image is already within threshold without scrolling.\n        if (shouldLoadImage(ref.current.offsetTop, yPosition)) {\n            loadImage();\n        } else {\n            window.addEventListener('scroll', handleScroll);\n        }\n\n        return () => {\n            removeListenersCallback();\n        };\n    }, [shouldLoadImage, loadImage, handleScroll, removeListenersCallback]);\n\n    const { src } = state;\n    return (\n        <img\n            ref={ref}\n            onLoad={onImageLoad}\n            className={props.className}\n            src={src}\n            alt={props.alt}\n            loading=\"lazy\"\n        />\n    );\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This Lazy Loading component defers process of fetching images and painting them onto the page, but this code will hurt your Cumulative Layout Shift. We'll look into how to fix that in the next section."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Using Placeholders Inside of Lazy Loading Containers"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The main issue with the lazy loading component is that we don't know how much space the image will need to take up on the screen."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"One way to work around this is to ensure all images have the same dimensions for the same component. A common pattern is to either ensure all the images have the same resolution and aspect ratio or to crop the image to make sure it fits in a fixed container."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/blogImages/seo_performance/fixed_images.jpg?width=1554&height=927&isResponsive=true&supportsWebp=true","alt":"Cropped Image"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"However, this doesn't work for all use-cases. For example, my blog has images with various aspect ratios and orientations. Some images are in landscape and some are in portrait. A common practice is to use the following CSS for responsive images."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"img {\n    width: 100%;\n    height: auto;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The issues with using height auto is that the browser doesn't know how much space to allocate until the image has been loaded. I got around this issue by adding some additional metadata to my images to preallocate the space without actually fetching the image. I added the expected width and height as a query parameter to the image."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"/blogImages/chromebook_coding/cover-2.jpg?width=1742&height=1306\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/blogImages/seo_performance/preallocated_img.jpg?width=2334&height=1256&isResponsive=true&supportsWebp=true","alt":"Preallocated Image"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The query parameters contain both the width and height of the image so I know exactly how much space to allocate. Then in the Lazy Load Image component, I set the initial state of "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"src"}]},{"type":"text","value":" with a placeholder svg using the width and height specified in the query params. This svg reserves the required space on the page before we fetch the image."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"const placeholderSrc = (img) => {\n    const { width, height } = img;\n    return `data:image/svg+xml,%3Csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${width} ${height}\"%3E%3C/svg%3E`;\n};\n\n...\n\nconst [state, setState] = useState({\n    loaded: false,\n    src: placeholderSrc(props),\n    ...\n});\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now your Lazy Loaded image won't have any issues with shifted layouts!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Using Appropriate Image Size for Certain Device Dimensions"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Lastly, I started added a srcset to my images. Essentially this tells the browser to use a different sized dimension based on its size. You can customize it such that when using a mobile device, it'll fetch a lower resolution image and a non mobile device will use a higher resolution image. On this site, each image has 6 variations: width of 240px, width of 320px, width of 480px, width of 720px, width of 960px, and the original image. I use the lower resolution photos when I expect the image won't exceed a certain size. For example, on the "},{"type":"element","tagName":"a","properties":{"href":"https://techwaifu.com/"},"children":[{"type":"text","value":"homepage of Techwaifu.com"}]},{"type":"text","value":", the images in the smaller article cards never exceed 300px, so I always use the "},{"type":"element","tagName":"a","properties":{"href":"http://techwaifu.com/blogImages/chromebook_coding/cover-2-320.jpg"},"children":[{"type":"text","value":"320px variation of the image"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/blogImages/seo_performance/fixed_width_img.jpg?width=1919&height=800&isResponsive=true&supportsWebp=true","alt":"Fixed Width Image"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When comparing the original image versus a shrunken variation of the image, you'll notice the original one will always take longer to download and is much larger to download. This is great for improving your site's performance since you won't need to fetch and render a 3200x2400 image on your 375x812 device. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/blogImages/seo_performance/original_img.jpg?width=1286&height=1061&isResponsive=true&supportsWebp=true","alt":"Original Image"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img-caption","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://techwaifu.com/blogImages/leica_cl/leica_summilux_tl_5.jpg"},"children":[{"type":"text","value":"Original Image"}]},{"type":"text","value":" | 299kB | 94ms to Download"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/blogImages/seo_performance/shrunken_img.jpg?width=1289&height=1000&isResponsive=true&supportsWebp=true","alt":"Compressed Image"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img-caption","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://techwaifu.com/blogImages/leica_cl/leica_summilux_tl_5-480.jpg"},"children":[{"type":"text","value":"Shrunken Image"}]},{"type":"text","value":" | 52.9kB | 47ms to Download"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now let's take a look at how this is done in the code. If you inspect an image on "},{"type":"element","tagName":"a","properties":{"href":"https://techwaifu.com/recommended-chromebooks-for-programming-2020-5734ed1a"},"children":[{"type":"text","value":"Techwaifu's blog"}]},{"type":"text","value":", you'll notice there's two attributes on the image other than src: sizes and srcset. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The sizes attribute determines which image from the srcset should be used. It's pretty flexible since you can change the image to fetch based on the device size using max-width. Take a look at this article on "},{"type":"element","tagName":"a","properties":{"href":"https://ericportis.com/posts/2014/srcset-sizes/%5D"},"children":[{"type":"text","value":"srcset and sizes"}]},{"type":"text","value":" for an in-depth guide."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"sizes=\"(max-width: 480px) 150px, 480px\"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The srcset contains all the different sized images with the width the image should be used at. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"srcset=\"/blogImages/ml_images/cover-240.jpg 240w, /blogImages/ml_images/cover-320.jpg 320w, /blogImages/ml_images/cover-480.jpg 480w, /blogImages/ml_images/cover-720.jpg 720w, /blogImages/ml_images/cover-960.jpg 960w\"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Altogether, the image tag looks like this."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"<img src=\"/blogImages/ml_images/cover-240.jpg\" sizes=\"(max-width: 480px) 150px, 480px\" srcset=\"/blogImages/ml_images/cover-240.jpg 240w, /blogImages/ml_images/cover-320.jpg 320w, /blogImages/ml_images/cover-480.jpg 480w, /blogImages/ml_images/cover-720.jpg 720w, /blogImages/ml_images/cover-960.jpg 960w\">\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"It's pretty easy to generate all the various images using "},{"type":"element","tagName":"a","properties":{"href":"https://www.npmjs.com/package/sharp"},"children":[{"type":"text","value":"Sharp"}]},{"type":"text","value":". Sharp can be used to resize images and even generate a "},{"type":"element","tagName":"a","properties":{"href":"https://developers.google.com/speed/webp"},"children":[{"type":"text","value":"webp"}]},{"type":"text","value":" variant. I used this code generate all the images at the different sizes. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"const fs = require('fs');\nconst sharp = require('sharp');\nconst shell = require('shelljs');\n\nconst XXS_WIDTH = 240;\nconst XS_WIDTH = 320;\nconst S_WIDTH = 480;\nconst M_WIDTH = 720;\nconst L_WIDTH = 960;\n\nconst compressedSizes = [\n    XXS_WIDTH,\n    XS_WIDTH,\n    S_WIDTH,\n    M_WIDTH,\n    L_WIDTH,\n];\n\nfunction resizeImages(imagePath) {\n    compressedSizes.forEach(width => {\n        const outPath = \"out/\" + imagePath.substring(0, imagePath.lastIndexOf(\"/\"));\n        // Create the folders for the output\n        if (!fs.existsSync(outPath)) {\n            shell.mkdir('-p', outPath);\n        }\n\n        // Generates jpg images\n        const outPathWithSize = imagePath.substring(0, imagePath.indexOf(\".\")) + \"-\" + width;\n\n        sharp(imagePath, {\n            failOnError: false\n        })\n        .clone()\n        .resize({ width: width })\n        .toFile(\"out/\" + outPathWithSize + \".jpg\").catch(err => console.log(err));\n    });\n}   \n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I also needed to update my Lazy Load component so the image will accept the srcset."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"const LazyLoadImage = (props) => {\n    const ref = useRef(null);\n    const [state, setState] = useState({\n        loaded: false,\n        src: placeholderSrc(props),\n        srcSet: null, \n        shouldFetch: true,\n    });\n\n    const removeListeners = () => {\n        window.removeEventListener(\"scroll\", handleScroll);\n    };\n\n    const removeListenersCallback = useCallback(removeListeners);\n\n    const loadImage = useCallback (() => {\n        setState({\n            ...state,\n            src: props.src,\n            shouldFetch: false,\n            srcset: props.srcset,\n        });\n        removeListenersCallback();\n    }, [state, removeListenersCallback, props]);\n\n    const shouldLoadImage = useCallback((componentOffsetTop, userYPosition) => {\n        return state.shouldFetch &&\n        !state.loaded &&\n        componentOffsetTop <= userYPosition + document.body.clientHeight + 500; \n    }, [state]);\n\n    const onImageLoad = () => {\n        if (!state.loaded && state.src === props.src) {\n            setState({\n                ...state,\n                loaded: true,\n            });\n        }\n    };\n\n    const onError = () => {\n        setState({\n            ...state,\n            loaded: true\n        });\n        removeListeners();\n    };\n\n    const handleScroll = useCallback(debounce(() => {\n        const yPosition = window.scrollY;\n        if (shouldLoadImage(ref.current.offsetTop, yPosition)) {\n            loadImage();\n        }\n    }, 100), [loadImage, shouldLoadImage]);\n\n    useEffect(() => {\n        const yPosition = window.scrollY;\n        // Handles initial mount to check if image is already within threshold without scrolling.\n        if (shouldLoadImage(ref.current.offsetTop, yPosition)) {\n            loadImage();\n        } else {\n            window.addEventListener('scroll', handleScroll);\n        }\n\n        return () => {\n            removeListenersCallback();\n        };\n    }, [shouldLoadImage, loadImage, handleScroll, removeListenersCallback]);\n\n    const { loaded, src, srcset  } = state;\n    const { sizes } = props;\n    return (\n        <img\n            ref={ref}\n            onLoad={onImageLoad}\n            onError={onError}\n            className={props.className}\n            src={src}\n            srcSet={srcset}\n            sizes={sizes}\n            alt={props.alt}\n            loading=\"lazy\"\n        />\n    );\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Congrats! Now you have a Lazy Loaded Image that supports different sized images using srcset."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Conclusion"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I primarily worked on optimizing the images on my site because images are usually the largest contentful item on each blog post. Using this lazy loaded component with the placeholder helped reduce my CLS from > 0.10 to 0. Lazy loading also reduced the initial render since the browser didn't have to paint all the images at once. Using srcsets also optimized how large each network request as well. I would recommend recommend looking at "},{"type":"element","tagName":"a","properties":{"href":"https://web.dev/vitals/"},"children":[{"type":"text","value":"web.dev"}]},{"type":"text","value":" to see their recommendations for improving site performance as well. Be sure to track your site's performance over time using "},{"type":"element","tagName":"a","properties":{"href":"https://developers.google.com/speed/pagespeed/insights/"},"children":[{"type":"text","value":"PageSpeed Insights"}]},{"type":"text","value":". Every time I made a change, I verified the before and after performance on that site to verify it really is an improvement. What changes have you made to your site to account for Google's algorithm change? Let me know in the comments section below and check out "},{"type":"element","tagName":"a","properties":{"href":"https://techwaifu.com/recommended-chromebooks-for-programming-2020-5734ed1a"},"children":[{"type":"text","value":"The Best Chromebooks for Programming in 2020"}]},{"type":"text","value":" to find your next laptop."}]}],"data":{"quirksMode":false}},"id":"9a58be87-ca9b-59e1-9bd5-5559b8ba6049","excerpt":"Wondering why your website's SEO ranking is constantly changing? Google is constantly tweaking their algorithm to improve search quality…","frontmatter":{"author":"awang","date":"August 22, 2020","modified_date":null,"slug":"blog/optimizing-website-performance-improve-seo-384b1f1b","title":"Optimizing Website Performance to Improve SEO Rank","tags":["website","coding","seo","computer science"],"cover_photo":"/blogImages/seo_performance/cover.jpg?width=736&height=686&isResponsive=true&supportsWebp=true","related_tag":"coding","is_travel_blog":null,"has_affiliate_links":null,"is_review":null,"brand_name":null,"item_name":null,"review_description":null,"score":null},"wordCount":{"words":1461},"fields":{"readingTime":{"text":"11 min read"}}},"relatedPosts":{"edges":[{"node":{"frontmatter":{"slug":"how-make-your-website-accessible-e77547a0","title":"How to make your website accessible","cover_photo":"/blogImages/accessibility/cover.jpg?width=740&height=453&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"ultimate-guide-coding-on-chromebook-bb405513","title":"Setting Up Java, Python, Node, React, and Angular on a Chromebook","cover_photo":"/blogImages/chromebook_coding/cover-2.jpg?width=1742&height=1306&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"coding-on-an-ipad-190ccc96","title":"Coding on an iPad","cover_photo":"/blogImages/code_on_ipad/cover.jpg?width=1024&height=715&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"blog/client-side-rendered-crawler-e08c0320","title":"Building an Instagram Crawler Using Node and Puppeteer","cover_photo":"/blogImages/crawler/cover.jpg?width=692&height=496&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"difference-between-studying-computer-science-working-software-engineer-df3bb680","title":"Programming in School vs Working as a Software Engineer","cover_photo":"/blogImages/school_vs_work/cover.jpg?width=1676&height=1257&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"how-to-host-a-website-for-free-5165ea28","title":"How to host a website for free","cover_photo":"/blogImages/free_website/cover.jpg?width=874&height=667&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"android-development-on-chromebook-2020-5734ed1a","title":"How to Develop Android Apps on a Chromebook in 2020","cover_photo":"/blogImages/mobile_dev_on_chromebook/cover.jpg?width=2400&height=1600&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"recommended-chromebooks-for-programming-2020-5734ed1a","title":"The Best Chromebooks for Programming in 2020","cover_photo":"/blogImages/recommended_chromebooks/acer_chromebook_spin.jpg?width=960&height=631&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"why-use-remote-procedure-calls-RPC-over-JSON-fbb4ae56","title":"Why Remote Procedure Calls (RPC) Are Better than REST","cover_photo":"/blogImages/grpc/cover.jpg?width=400&height=400&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"what-is-structured-data-and-why-do-i-need-it-a3f06898","title":"What is Structured Data and Why do I need it?","cover_photo":"/blogImages/structured_data/cover.jpg?width=981&height=327&isResponsive=true&supportsWebp=true"}}}]}},"pageContext":{"slug":"blog/optimizing-website-performance-improve-seo-384b1f1b","relatedTag":"coding"}}}