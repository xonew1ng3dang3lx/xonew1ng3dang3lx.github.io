{"componentChunkName":"component---src-templates-blog-page-markdown-index-js","path":"/difference-between-studying-computer-science-working-software-engineer-df3bb680","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://techwaifu.com"}},"blog":{"html":"<p>While I started studying Computer Science, I always wondered if working in the real world would be as difficult as college. I struggled to learn a lot of the theories and constantly wondered why I had to take most of these courses. It turns out the real world is much different from school.</p>\n<h2>The Academia Side of Computer Science</h2>\n<p>While studying computer science at a university, professors will generally teach you about the science of programming. Hence you'll take a lot of theory and math courses to understand the fundamentals of how programming works behind the scenes. A typical university curriculum may include some of the following topics:</p>\n<ul>\n<li>Data Structures and Analysis of Algorithms</li>\n<li>Theory of Computation</li>\n<li>Operating Systems</li>\n<li>The Fundamental Concepts of Languages</li>\n<li>Compilers</li>\n<li>Computer Organization, Systems Programming, and Computer Architecture</li>\n<li>Probability and Statistics</li>\n</ul>\n<p>Generally, the assignments are well defined problems with known solutions. These assignments are meant to be solved within a well defined time span. It is very unlikely that undergraduates will be given assignments with unclear requirements since these courses are meant to help you learn a specific Computer Science topic. All in all, getting a degree in Computer Science will teach you how to write and debug basic code and how apply the theories taught in lecture. </p>\n<h2>What it's like working in the workforce as a Computer Engineer</h2>\n<p>The truth is, most university curriculums don't prepare students how to operate in a real work environment. A common misconception is that Software Engineers just sit at their desks chugging coffee and coding all day. However, this is far from reality.</p>\n<h3>Writing code</h3>\n<p>All entry level Software Engineers spend 80% of their time writing code. The other 20% revolve around going to meetings and attending scrum. Generally, PMs and a Techlead plan out the deliverables that have already been scoped out. These deliverables are small enough for any engineer to code out. Sometimes the Techlead will also provide a design doc when the implementation portion is unclear for entry level Software Engineers. Most of the smaller tasks have predefined requirements by the PMs and Techlead. Software Engineers need to digest the requirements and transform it into code.</p>\n<p>One big difference between writing code at a university and in the real world is that most university courses don't focus on how to code in a large codebase. In the real world, you'll rarely get to start on a fresh codebase or a get skeleton that's provided by someone else. Also in the real world, most projects can take months to complete unlike university assignments which span a week to complete. However, when you start in the industry you'll notice one similarity, the requirements are all flushed out. Both university assignments and entry level tasks have clear requirements that have already been defined by someone else. You'll see as you grow in your career, this starts to change very quickly.</p>\n<h3>Designing Systems</h3>\n<p>It's important to note that in the workplace, you'll be creating products and solving real problems for real people. Hence, a lot more thought goes into designing the system as a whole.</p>\n<p>As you advance in your career, you'll start to write less code and start to design larger systems. When I started my career, my tech leads would give me a design doc to implement. As I advanced in my career, I started to design systems with much larger scope that were meant for multiple engineers to work on. Part of this includes analyzing requirements and understanding what is technically feasible in a given timeframe. This also requires you to have a solid technical background in order to figure out what frameworks or solutions to apply.</p>\n<p>You'll rarely use those advanced concepts taught in school. Most of the time you'll be using APIs of other frameworks or libraries. In 95% of my projects, I had to learn about other systems or frameworks and figure out how to piece them together to create something new. For example, when I made a web app, I had to learn how to use React and someone else's calendar Widget. I had to figure out how to piece their calendar widget with my React form and the best way to propagate data back and forth. However, knowing those concepts are important when applying those frameworks to your code. Being able to recognize using a certain function can turn your runtime from O(n^2) to O(n) is extremely valuable.</p>\n<p>None of my courses taught me the importance of designing the system before starting to write code. In my courses, as long as my code compiled and passed the tests it was good to go. There was never a reason to design more than one working solution. In my current workplace, I have multiple options each listed with pros and cons. I have thoughtful discussions with other engineers on the best solution.</p>\n<p>Real world problems are often complex and blurry. Requirements can change overtime. You're often designing systems that can be replaced or refactored in the future. This is because in the real world, you're focused on designing solutions for real people.</p>\n<h3>Testing the system and maintaining upkeep of that system</h3>\n<p>I noticed a lot of Software Engineers entering this field don't learn the importance of testing until they start working. Often, universities provide a test suite that the students can run against to verify their solution is working. In a production codebase, you'll have to check in tests with the code. Depending on the feature, it could be an integration test, unit test, or a visual test.</p>\n<p>In the real world, you'll also have to maintain that test and the system. I learned that tests can be flaky time to time. Things like Webdriver tests aren't perfect and sometimes you'll need to revisit your existing tests to make them stable again. Production code is used by real people, so it's detrimental if your system crashes and goes down. Unlike a college assignment, you'll need to invest time into logging, capturing metrics, and scaling the system. </p>\n<h3>Collaborating with PMs, UX, Stakeholders, and other Software Engineers</h3>\n<p>Contrary to common belief, Software Engineers are not locked up in their code coding in the dark and hiding from humanity. In reality Software Engineers have to collaborate with Product Managers, UX Designers, Stakeholders, and other Engineers. PMs have a good idea of the problem that needs to get solved. UX Designers know how to create beautiful mocks and understand human interaction principals. Software Engineers know how to take both the requirements and mocks and turn them into working code.</p>\n<p>I noticed it's a constant tug of war between adding new requirements and balancing tech debt. Sometimes PM or UX requirements have challenging implications such as increased tech debt or the solution may take too long to complete in the given time frame. It's up to the Software Engineers to flag this and work with the respective parties to come to a balanced solution.</p>\n<h3>Estimating the time and effort required to build out a system in a given timeframe</h3>\n<p>Another thing Software Engineers have to do is estimate how long it will take to complete a project. Leadership takes these estimates in order to figure out how to sequence things. Figuring out how difficult and how long a project can is also a good trait to learn. In school, you're generally bound to a fixed deadline, but in the real workplace, deadlines are more flexible since they're set based on the amount of work required.</p>\n<h2>Conclusion</h2>\n<p>In conclusion, university curriculums teach students how computers interpret programming languages and how to utilize different data structures and algorithms, but it's different from how things are in the industry. In the industry, you'll be expected to design real systems for real people. Projects will take much longer to complete due to the larger scope. However, university curriculums help provide the fundamentals required in the work place. If this article was interesting, take a look on <a href=\"https://techwaifu.com/how-i-got-multiple-fang-offers-e0a87898\">how I Landed Offers from Facebook, Google, Uber, &#x26; Microsoft as a Software Engineer</a>. Did you get a Computer Science degree? Do you think it was useful? Let me know in the comments section below.</p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"While I started studying Computer Science, I always wondered if working in the real world would be as difficult as college. I struggled to learn a lot of the theories and constantly wondered why I had to take most of these courses. It turns out the real world is much different from school."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"The Academia Side of Computer Science"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"While studying computer science at a university, professors will generally teach you about the science of programming. Hence you'll take a lot of theory and math courses to understand the fundamentals of how programming works behind the scenes. A typical university curriculum may include some of the following topics:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Data Structures and Analysis of Algorithms"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Theory of Computation"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Operating Systems"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"The Fundamental Concepts of Languages"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Compilers"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Computer Organization, Systems Programming, and Computer Architecture"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Probability and Statistics"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Generally, the assignments are well defined problems with known solutions. These assignments are meant to be solved within a well defined time span. It is very unlikely that undergraduates will be given assignments with unclear requirements since these courses are meant to help you learn a specific Computer Science topic. All in all, getting a degree in Computer Science will teach you how to write and debug basic code and how apply the theories taught in lecture. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"What it's like working in the workforce as a Computer Engineer"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The truth is, most university curriculums don't prepare students how to operate in a real work environment. A common misconception is that Software Engineers just sit at their desks chugging coffee and coding all day. However, this is far from reality."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Writing code"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"All entry level Software Engineers spend 80% of their time writing code. The other 20% revolve around going to meetings and attending scrum. Generally, PMs and a Techlead plan out the deliverables that have already been scoped out. These deliverables are small enough for any engineer to code out. Sometimes the Techlead will also provide a design doc when the implementation portion is unclear for entry level Software Engineers. Most of the smaller tasks have predefined requirements by the PMs and Techlead. Software Engineers need to digest the requirements and transform it into code."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"One big difference between writing code at a university and in the real world is that most university courses don't focus on how to code in a large codebase. In the real world, you'll rarely get to start on a fresh codebase or a get skeleton that's provided by someone else. Also in the real world, most projects can take months to complete unlike university assignments which span a week to complete. However, when you start in the industry you'll notice one similarity, the requirements are all flushed out. Both university assignments and entry level tasks have clear requirements that have already been defined by someone else. You'll see as you grow in your career, this starts to change very quickly."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Designing Systems"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"It's important to note that in the workplace, you'll be creating products and solving real problems for real people. Hence, a lot more thought goes into designing the system as a whole."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"As you advance in your career, you'll start to write less code and start to design larger systems. When I started my career, my tech leads would give me a design doc to implement. As I advanced in my career, I started to design systems with much larger scope that were meant for multiple engineers to work on. Part of this includes analyzing requirements and understanding what is technically feasible in a given timeframe. This also requires you to have a solid technical background in order to figure out what frameworks or solutions to apply."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"You'll rarely use those advanced concepts taught in school. Most of the time you'll be using APIs of other frameworks or libraries. In 95% of my projects, I had to learn about other systems or frameworks and figure out how to piece them together to create something new. For example, when I made a web app, I had to learn how to use React and someone else's calendar Widget. I had to figure out how to piece their calendar widget with my React form and the best way to propagate data back and forth. However, knowing those concepts are important when applying those frameworks to your code. Being able to recognize using a certain function can turn your runtime from O(n^2) to O(n) is extremely valuable."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"None of my courses taught me the importance of designing the system before starting to write code. In my courses, as long as my code compiled and passed the tests it was good to go. There was never a reason to design more than one working solution. In my current workplace, I have multiple options each listed with pros and cons. I have thoughtful discussions with other engineers on the best solution."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Real world problems are often complex and blurry. Requirements can change overtime. You're often designing systems that can be replaced or refactored in the future. This is because in the real world, you're focused on designing solutions for real people."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Testing the system and maintaining upkeep of that system"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I noticed a lot of Software Engineers entering this field don't learn the importance of testing until they start working. Often, universities provide a test suite that the students can run against to verify their solution is working. In a production codebase, you'll have to check in tests with the code. Depending on the feature, it could be an integration test, unit test, or a visual test."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In the real world, you'll also have to maintain that test and the system. I learned that tests can be flaky time to time. Things like Webdriver tests aren't perfect and sometimes you'll need to revisit your existing tests to make them stable again. Production code is used by real people, so it's detrimental if your system crashes and goes down. Unlike a college assignment, you'll need to invest time into logging, capturing metrics, and scaling the system. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Collaborating with PMs, UX, Stakeholders, and other Software Engineers"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Contrary to common belief, Software Engineers are not locked up in their code coding in the dark and hiding from humanity. In reality Software Engineers have to collaborate with Product Managers, UX Designers, Stakeholders, and other Engineers. PMs have a good idea of the problem that needs to get solved. UX Designers know how to create beautiful mocks and understand human interaction principals. Software Engineers know how to take both the requirements and mocks and turn them into working code."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I noticed it's a constant tug of war between adding new requirements and balancing tech debt. Sometimes PM or UX requirements have challenging implications such as increased tech debt or the solution may take too long to complete in the given time frame. It's up to the Software Engineers to flag this and work with the respective parties to come to a balanced solution."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Estimating the time and effort required to build out a system in a given timeframe"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Another thing Software Engineers have to do is estimate how long it will take to complete a project. Leadership takes these estimates in order to figure out how to sequence things. Figuring out how difficult and how long a project can is also a good trait to learn. In school, you're generally bound to a fixed deadline, but in the real workplace, deadlines are more flexible since they're set based on the amount of work required."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Conclusion"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In conclusion, university curriculums teach students how computers interpret programming languages and how to utilize different data structures and algorithms, but it's different from how things are in the industry. In the industry, you'll be expected to design real systems for real people. Projects will take much longer to complete due to the larger scope. However, university curriculums help provide the fundamentals required in the work place. If this article was interesting, take a look on "},{"type":"element","tagName":"a","properties":{"href":"https://techwaifu.com/how-i-got-multiple-fang-offers-e0a87898"},"children":[{"type":"text","value":"how I Landed Offers from Facebook, Google, Uber, & Microsoft as a Software Engineer"}]},{"type":"text","value":". Did you get a Computer Science degree? Do you think it was useful? Let me know in the comments section below."}]}],"data":{"quirksMode":false}},"id":"ee4889c3-77f4-5188-a27d-d9c07490b701","excerpt":"While I started studying Computer Science, I always wondered if working in the real world would be as difficult as college. I struggled to…","frontmatter":{"author":"awang","date":"July 29, 2020","modified_date":null,"slug":"difference-between-studying-computer-science-working-software-engineer-df3bb680","title":"Programming in School vs Working as a Software Engineer","tags":["programming","coding","computer science"],"cover_photo":"/blogImages/school_vs_work/cover.jpg?width=1676&height=1257&isResponsive=true&supportsWebp=true","related_tag":"coding","is_travel_blog":null,"has_affiliate_links":null,"is_review":null,"brand_name":null,"item_name":null,"review_description":null,"score":null},"wordCount":{"words":1360},"fields":{"readingTime":{"text":"7 min read"}}},"relatedPosts":{"edges":[{"node":{"frontmatter":{"slug":"how-make-your-website-accessible-e77547a0","title":"How to make your website accessible","cover_photo":"/blogImages/accessibility/cover.jpg?width=740&height=453&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"ultimate-guide-coding-on-chromebook-bb405513","title":"Setting Up Java, Python, Node, React, and Angular on a Chromebook","cover_photo":"/blogImages/chromebook_coding/cover-2.jpg?width=1742&height=1306&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"coding-on-an-ipad-190ccc96","title":"Coding on an iPad","cover_photo":"/blogImages/code_on_ipad/cover.jpg?width=1024&height=715&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"blog/client-side-rendered-crawler-e08c0320","title":"Building a Crawler for a Client-side Rendered Web App","cover_photo":"/blogImages/crawler/cover.jpg?width=692&height=496&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"how-to-host-a-website-for-free-5165ea28","title":"How to host a website for free","cover_photo":"/blogImages/free_website/cover.jpg?width=874&height=667&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"android-development-on-chromebook-2020-5734ed1a","title":"How to Develop Android Apps on a Chromebook in 2020","cover_photo":"/blogImages/mobile_dev_on_chromebook/cover.jpg?width=2400&height=1600&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"recommended-chromebooks-for-programming-2020-5734ed1a","title":"The Best Chromebooks for Programming in 2020","cover_photo":"/blogImages/recommended_chromebooks/acer_chromebook_spin.jpg?width=960&height=631&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"what-is-structured-data-and-why-do-i-need-it-a3f06898","title":"What is Structured Data and Why do I need it?","cover_photo":"/blogImages/structured_data/cover.jpg?width=981&height=327&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"why-use-remote-procedure-calls-RPC-over-JSON-fbb4ae56","title":"Why Remote Procedure Calls (RPC) Are Better than REST","cover_photo":"/blogImages/grpc/cover.jpg?width=400&height=400&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"importance-of-code-quality-impact-of-tech-debt-1fb19358","title":"The Importance of Code Quality and the Impact of Technical Debt","cover_photo":"/blogImages/tech_debt/cover.jpg?width=1450&height=1087&isResponsive=true&supportsWebp=true"}}}]}},"pageContext":{"slug":"difference-between-studying-computer-science-working-software-engineer-df3bb680","relatedTag":"coding"}}}