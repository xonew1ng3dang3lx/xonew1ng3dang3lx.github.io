{"componentChunkName":"component---src-templates-blog-page-markdown-index-js","path":"/importance-of-code-quality-impact-of-tech-debt-1fb19358","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://techwaifu.com"}},"blog":{"html":"<p>At the beginning of my career I didn't care too much about code quality. As long as the code compiled and worked why did it matter right? Wrong. In school, we never learned the importance of writing maintainable code. Back in school, our assignments lasted at most a week or two and then we started a new project from scratch the next week. I kept this mentality with me to my first job and learned the hard way how difficult it becomes to add new features on top of bad quality code. The term for this is called technical debt or tech debt for short.</p>\n<h2>How does tech debt come to be?</h2>\n<p>Let's describe the different ways tech debt can form. The most common form of tech debt comes from the backlog of bugs and hacks that have piled up in the codebase and nobody wants to fix. Other less obvious forms of tech debt include lack of tests, a bad design, use of legacy frameworks and libraries, or a lack of thorough code reviews. I see this most common when teams have a tight deadline requiring teams to churn out code without maintaining good code. I also see this when the engineering teams are forced to start implementation without a clear set of requirements or UX mocks.</p>\n<p>Unfortunately many do not take tech debt seriously. This kind of debt is not the same as how businesses can take on debt to expand their business. This kind of tech debt has an inverse effect where adding new features and maintaining code quality is a constant tug of war with each other.</p>\n<h2>Sounds Bad But If the Product Works, Why Should I Care?</h2>\n<p>Let's think back to that time you had to implement that hack you said you would fix later, but 3 months later you're hit with a bug that takes a week to fix. This is only the start of the impact from tech debt.</p>\n<p>Now let's look at a more severe case of unmanaged tech debt. The PMs come asking you to implement that new shiny feature. You start coding away, but realize how difficult it is to implement this feature without adding more hacks on top of existing hacks. A week later you come back to the same codebase and you have no idea what you wrote. Ok whatever right? Your PM comes back with another feature request and you start churning code. But this time it takes you two weeks to implement this feature due to how complex the codebase has become.</p>\n<p>TLDR: Unmanaged tech debt can lead up to a point where it becomes impossible to add new feature, extend deadlines beyond control, or demotivate engineers to touch that code. It can also make it easier to introduce unexpected bugs since the codebase becomes more brittle and fragile.</p>\n<h2>How can we tell when too much tech debt has incurred?</h2>\n<p>It's not impossible to control tech debt if we have ways to detect it. Let's look at some obvious signals of incurring tech debt.</p>\n<ul>\n<li>Harder to make new features </li>\n<li>Code becomes more tedious to test via unit/integration tests</li>\n<li>Too many TODOs and HACKs in the code</li>\n<li>Lower velocity</li>\n</ul>\n<p>The last two points can be tracked with tools such as Jira or some other project management tools.</p>\n<h3>Too many TODOs and HACKs in the code</h3>\n<p>A good practice to track TODOs, bugs, and hacks is to create a tracker for each item and add a comment in your code so others can easily check the bug. I like to do the following:</p>\n<pre><code>// TODO(issues/1#issue-670532172): Remove the name param once we support id to name conversion.\nfunction doThing(id, name) {} \n\n// HACK(issues/1#issue-670532172): Setting document.window so we can work around blah blah.\ndocument.window = windowWorkAround();\n</code></pre>\n<p>This makes it much more apparent which parts of the code are using a hack or needs to be updated in the future. Anyone reading the code can easily lookup the tracker and read the tracker for more context.</p>\n<p>There were many times I told myself I would go back and fix that bug, but forgot about it a week later. So having a solid record makes it easier for you and other team members to see what's going on. Leaving a record is also important when people leave the team. Not everyone stays in the same team or company their entire career, so it's best to leave some context for that poor soul who will have to handle that bug when the original author has left.</p>\n<h3>Lower Velocity</h3>\n<p>Let's first talk about what is velocity. Velocity is a measure of how fast a team can deliver a requirement. Velocity can be calculated by how quickly the team can complete tasks during a sprint which are usually weekly or biweekly. These tasks are also paired with an estimated time or complexity to weight the task appropriately. The velocity of the team can be used to determine how much work a team can take on for that specific sprint.</p>\n<p>Tech debt can impact velocity and usually in a negative manner. Usually it can make the estimates higher than it should be since features might be harder to fix or refactoring is required. Sometimes tasks are underestimated and end up taking much longer to complete due to the required refactoring or the extra hack. Other times it can cause the team to want to avoid taking on ownership of a specific task due to how difficult it is to address. All in all, unaddressed tech debt can and will extend development time.</p>\n<h2>How to manage tech debt</h2>\n<p>Throughout my career, I've seen teams approach tech debt differently. I've compiled a list of some of the methods to do so, but I think the first step to take is having a culture change.</p>\n<h3>Changing Team Culture Regarding Code Quality</h3>\n<p>As a junior Software Engineer, I wasn't aware of the implications of tech debt until I attended a Code Health conference. I'm now a firm believer that team awareness on this topic is critical in order to changing the team's mentality towards tech debt. Most developers would rather create brand new features than fix some bug. Who doesn't right? New features are usually the most existing things to add and create impact. This is why it's important to have a good team culture regarding fixing bugs. The team should weigh those bug fixes just as important as anything else because it impacts the overall team indirectly.</p>\n<h3>Having a Rotational On-duty Person</h3>\n<p>In my team, we have a weekly on-duty rotation where the on-duty person stops working on their features for the week to focus on the backlog or fixing broken integration tests. This will ensure tech debt is never neglected since someone will always been looking into it. This is also a great way for new members to onboard and learn about the whole system since they can work on parts of the code no one usually touches.</p>\n<h3>Pushing Back On Feature Requests</h3>\n<p>Sometimes the best way to balance tech debt is to work with PMs and UX on compromise. If they ask for a certain feature that requires a hack try to work with them on alternate solutions so all parties can be happy. It is also important to communicate how long features may take due to required refactoring. I don't think we should say no completely, but having a compromise on both ends maintains a healthy balance between new features and tech debt.</p>\n<h3>Recurring Bug Bashes</h3>\n<p>One thing my team does is a yearly bug bash where we stop working on features and focus on any lingering bugs, hacks, or infrastructure improvements for a week. To make it fun, we have a tracker of the number of bugs fixed. Although, don't ignore all your tech debt until these bug bashes occur!</p>\n<h3>Migrating Pieces of Legacy Code</h3>\n<p>I've noticed tech debt incurs in both new and legacy codebases. However, legacy codebases are plagued by old frameworks, libraries, programming languages, and old coding conventions. Sometimes the best way to tackle this is by slowly migrating those pieces of code. If you're dealing with a monolithic server, consider breaking it up into micro services piece by piece. If you're dealing with a UI on an old framework, look into building new components in a new framework. You don't always have to be locked down to your current tech stack just because the it's been that way for ages. </p>\n<h3>Sometimes Starting From Scratch Is Best</h3>\n<p>Sometimes starting over is the best approach. My team spent the last 4 years rewriting the entire product from scratch to abandon the decade old tech stack it was written on. It's important to quantify and communicate to leadership the benefits and expected outcomes from starting over. Some good metrics to communicate can include faster release times, a more comprehensible codebase, faster development times, and feasability for new features. Leadership needs to convinced there is some sort of positive impact towards the business. </p>\n<h2>Conclusion</h2>\n<p>Has tech debt plagued you in the past? What did your team do to approach it? Leave a comment in the comments section below!</p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"At the beginning of my career I didn't care too much about code quality. As long as the code compiled and worked why did it matter right? Wrong. In school, we never learned the importance of writing maintainable code. Back in school, our assignments lasted at most a week or two and then we started a new project from scratch the next week. I kept this mentality with me to my first job and learned the hard way how difficult it becomes to add new features on top of bad quality code. The term for this is called technical debt or tech debt for short."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"How does tech debt come to be?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let's describe the different ways tech debt can form. The most common form of tech debt comes from the backlog of bugs and hacks that have piled up in the codebase and nobody wants to fix. Other less obvious forms of tech debt include lack of tests, a bad design, use of legacy frameworks and libraries, or a lack of thorough code reviews. I see this most common when teams have a tight deadline requiring teams to churn out code without maintaining good code. I also see this when the engineering teams are forced to start implementation without a clear set of requirements or UX mocks."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Unfortunately many do not take tech debt seriously. This kind of debt is not the same as how businesses can take on debt to expand their business. This kind of tech debt has an inverse effect where adding new features and maintaining code quality is a constant tug of war with each other."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sounds Bad But If the Product Works, Why Should I Care?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let's think back to that time you had to implement that hack you said you would fix later, but 3 months later you're hit with a bug that takes a week to fix. This is only the start of the impact from tech debt."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now let's look at a more severe case of unmanaged tech debt. The PMs come asking you to implement that new shiny feature. You start coding away, but realize how difficult it is to implement this feature without adding more hacks on top of existing hacks. A week later you come back to the same codebase and you have no idea what you wrote. Ok whatever right? Your PM comes back with another feature request and you start churning code. But this time it takes you two weeks to implement this feature due to how complex the codebase has become."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"TLDR: Unmanaged tech debt can lead up to a point where it becomes impossible to add new feature, extend deadlines beyond control, or demotivate engineers to touch that code. It can also make it easier to introduce unexpected bugs since the codebase becomes more brittle and fragile."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"How can we tell when too much tech debt has incurred?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"It's not impossible to control tech debt if we have ways to detect it. Let's look at some obvious signals of incurring tech debt."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Harder to make new features "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Code becomes more tedious to test via unit/integration tests"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Too many TODOs and HACKs in the code"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Lower velocity"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The last two points can be tracked with tools such as Jira or some other project management tools."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Too many TODOs and HACKs in the code"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A good practice to track TODOs, bugs, and hacks is to create a tracker for each item and add a comment in your code so others can easily check the bug. I like to do the following:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"// TODO(issues/1#issue-670532172): Remove the name param once we support id to name conversion.\nfunction doThing(id, name) {} \n\n// HACK(issues/1#issue-670532172): Setting document.window so we can work around blah blah.\ndocument.window = windowWorkAround();\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This makes it much more apparent which parts of the code are using a hack or needs to be updated in the future. Anyone reading the code can easily lookup the tracker and read the tracker for more context."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There were many times I told myself I would go back and fix that bug, but forgot about it a week later. So having a solid record makes it easier for you and other team members to see what's going on. Leaving a record is also important when people leave the team. Not everyone stays in the same team or company their entire career, so it's best to leave some context for that poor soul who will have to handle that bug when the original author has left."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Lower Velocity"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let's first talk about what is velocity. Velocity is a measure of how fast a team can deliver a requirement. Velocity can be calculated by how quickly the team can complete tasks during a sprint which are usually weekly or biweekly. These tasks are also paired with an estimated time or complexity to weight the task appropriately. The velocity of the team can be used to determine how much work a team can take on for that specific sprint."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tech debt can impact velocity and usually in a negative manner. Usually it can make the estimates higher than it should be since features might be harder to fix or refactoring is required. Sometimes tasks are underestimated and end up taking much longer to complete due to the required refactoring or the extra hack. Other times it can cause the team to want to avoid taking on ownership of a specific task due to how difficult it is to address. All in all, unaddressed tech debt can and will extend development time."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"How to manage tech debt"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Throughout my career, I've seen teams approach tech debt differently. I've compiled a list of some of the methods to do so, but I think the first step to take is having a culture change."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Changing Team Culture Regarding Code Quality"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"As a junior Software Engineer, I wasn't aware of the implications of tech debt until I attended a Code Health conference. I'm now a firm believer that team awareness on this topic is critical in order to changing the team's mentality towards tech debt. Most developers would rather create brand new features than fix some bug. Who doesn't right? New features are usually the most existing things to add and create impact. This is why it's important to have a good team culture regarding fixing bugs. The team should weigh those bug fixes just as important as anything else because it impacts the overall team indirectly."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Having a Rotational On-duty Person"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In my team, we have a weekly on-duty rotation where the on-duty person stops working on their features for the week to focus on the backlog or fixing broken integration tests. This will ensure tech debt is never neglected since someone will always been looking into it. This is also a great way for new members to onboard and learn about the whole system since they can work on parts of the code no one usually touches."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Pushing Back On Feature Requests"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Sometimes the best way to balance tech debt is to work with PMs and UX on compromise. If they ask for a certain feature that requires a hack try to work with them on alternate solutions so all parties can be happy. It is also important to communicate how long features may take due to required refactoring. I don't think we should say no completely, but having a compromise on both ends maintains a healthy balance between new features and tech debt."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Recurring Bug Bashes"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"One thing my team does is a yearly bug bash where we stop working on features and focus on any lingering bugs, hacks, or infrastructure improvements for a week. To make it fun, we have a tracker of the number of bugs fixed. Although, don't ignore all your tech debt until these bug bashes occur!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Migrating Pieces of Legacy Code"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I've noticed tech debt incurs in both new and legacy codebases. However, legacy codebases are plagued by old frameworks, libraries, programming languages, and old coding conventions. Sometimes the best way to tackle this is by slowly migrating those pieces of code. If you're dealing with a monolithic server, consider breaking it up into micro services piece by piece. If you're dealing with a UI on an old framework, look into building new components in a new framework. You don't always have to be locked down to your current tech stack just because the it's been that way for ages. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Sometimes Starting From Scratch Is Best"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Sometimes starting over is the best approach. My team spent the last 4 years rewriting the entire product from scratch to abandon the decade old tech stack it was written on. It's important to quantify and communicate to leadership the benefits and expected outcomes from starting over. Some good metrics to communicate can include faster release times, a more comprehensible codebase, faster development times, and feasability for new features. Leadership needs to convinced there is some sort of positive impact towards the business. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Conclusion"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Has tech debt plagued you in the past? What did your team do to approach it? Leave a comment in the comments section below!"}]}],"data":{"quirksMode":false}},"id":"9bec63ce-436c-5e7d-b184-e5c499a6afe7","excerpt":"At the beginning of my career I didn't care too much about code quality. As long as the code compiled and worked why did it matter rightâ€¦","frontmatter":{"author":"awang","date":"August 1, 2020","modified_date":null,"slug":"importance-of-code-quality-impact-of-tech-debt-1fb19358","title":"The Importance of Code Quality and the Impact of Technical Debt","tags":["programming","coding","tech debt","computer science"],"cover_photo":"/blogImages/accessibility/cover.jpg","related_tag":"coding","is_travel_blog":null,"has_affiliate_links":null,"is_review":null,"brand_name":null,"item_name":null,"review_description":null,"score":null},"wordCount":{"words":1493},"fields":{"readingTime":{"text":"8 min read"}}},"relatedPosts":{"edges":[{"node":{"frontmatter":{"slug":"how-make-your-website-accessible-e77547a0","title":"How to make your website accessible","cover_photo":"/blogImages/accessibility/cover.jpg"}}},{"node":{"frontmatter":{"slug":"coding-on-an-ipad-190ccc96","title":"Coding on an iPad","cover_photo":"/blogImages/code_on_ipad/cover.jpg"}}},{"node":{"frontmatter":{"slug":"difference-between-studying-computer-science-working-software-engineer-df3bb680","title":"Programming in School vs Working as a Software Engineer","cover_photo":"/blogImages/school_vs_work/cover.jpg"}}}]}},"pageContext":{"slug":"importance-of-code-quality-impact-of-tech-debt-1fb19358","relatedTag":"coding"}}}