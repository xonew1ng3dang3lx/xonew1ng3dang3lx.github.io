{"componentChunkName":"component---src-templates-blog-page-markdown-index-js","path":"/why-use-remote-procedure-calls-RPC-over-JSON-fbb4ae56","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://techwaifu.com"}},"blog":{"html":"<p>Most modern services and clients communicate with REST with JSON as a data interchange format. JSON is easy to read and most programming languages can easily parse JSON. The ease of use comes with its cons though. You can't enforce a well defined structure and protocol between the client and server. You can send extra data that the recipient doesn't care about. JSON is also pretty big in terms of size compared to protos. Let's take a look at protos and how it can solve some of those issues.</p>\n<h2>What Does a Protobuf look like?</h2>\n<p>There are different versions of proto in GRPC, but I'll be referencing <a href=\"https://developers.google.com/protocol-buffers/docs/proto\">proto3</a> which is the newest version.</p>\n<pre><code>syntax = \"proto3\";\n\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 result_per_page = 3;\n}\n</code></pre>\n<p>A typical proto looks like this. Each field has a type (string), a field name (query), and a unique field number (1). The field number is used to figure out how to encode the field and its location.</p>\n<h2>Protos Establish a Schema</h2>\n<p>As you saw in the example earlier, the proto defined a schema of a SearchRequest. Having a schema is important because it guarantees type-safety and prevents schema-violations. The best part of protos is that you can have a server implementation in one language and a client in a different language and the proto can be consumed without any difficulty.</p>\n<p>In GRPC, you can also define services which are like REST endpoints. Let's expand on the example from above.</p>\n<pre><code>syntax = \"proto3\";\n\nservice SearchService {\n  rpc Search (SearchRequest) returns (SearchResponse);\n}\n\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 result_per_page = 3;\n}\n\nmessage SearchResponse {\n  string response = 1;\n}\n</code></pre>\n<p>Let's say we have a Go server that implements <code>SearchService</code>. The implementation will look something like.</p>\n<pre><code>type searchServer struct {}\n\nfunc (s *searchServer) Search(ctx context.Context, req *pb.SearchRequest) (*pb.SearchResponse, error) {\n  // TODO: Implement the Server\n}\n</code></pre>\n<p>A Javascript Client can the server like so</p>\n<pre><code>const service = new SearchServiceClient('http://localhost:8080');\n\nconst req = new SearchRequest();\nreq.setQuery(\"AnimalCrossing\");\nreq.setPageNumber(3);\nreq.setResultsPerPage(100);\n\nservice.search(req, {}, (err, resp) => {});\n</code></pre>\n<p>An equivalent client in REST would look like so: </p>\n<pre><code>const data = {\n    query: \"AnimalCrossing\",\n  pageNumber: 3,\n  resultsPerPage: 100,\n};\n\nfetch(\"/search\", data);\n</code></pre>\n<p>The problem with the 2nd approach is that you cannot guarentee any type safety or check for required fields without extra business logic. You can also set a field incorrectly like using <code>page_number</code> instead of <code>pageNumber</code>. I also think the RPC version is much more readable. You can tell exactly what the data is by reading the object name.</p>\n<p>REST based APIs do not have schema out of the box. If you want to give your REST API a schema, you'll need to use something like <a href=\"http://json-schema.org/\">JSON Schema</a>.</p>\n<h2>Network Requests Transmit Less Bytes</h2>\n<p>Let's see how SearchRequest might look like in JSON vs proto. Let's say the client sets query to \"animal crossing\", <code>page_number</code> to 3, and <code>result_per_page</code> to 100. Once this proto is populated and serialized, it will look something like this <code>[\"animal crossing\",3,100]</code>. In JSON, you'll represent the same object like so:</p>\n<pre><code>{\n    \"query\": \"animal crossing\",\n    \"page_number\": 3,\n    \"result_per_page\": 100\n}\n</code></pre>\n<p>You can already tell the serialized proto version requires less characters to represent than the equivalent in JSON. This is really good for companies that need to shave as much data off each request/response to make network requests as small as possible. The only issue is the serialized proto is not easy for a human being to read.</p>\n<h2>Protos Can Be Used In a Plethora of Programming Languages</h2>\n<p>Just like REST, RPCs and protos can be consumed by any programming language. Here's some tutorials from Google on how to set up <a href=\"https://developers.google.com/protocol-buffers/docs/tutorials\">protos</a>. There are also open source projects to set up protos for other programming languages like <a href=\"https://github.com/protobufjs/protobuf.js\">protobuf.js</a>.</p>\n<h2>Conclusion</h2>\n<p>In conclusion, I'm a big fan of how RPCs define a clear and well defined schema and transmits less bytes over the wire. I also think using protos help increase the readability of the code since everything is typed and objects are initialized with the proto object. Have you used RPCs before? Do you prefer that over REST? Let me know in the comments section below.</p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Most modern services and clients communicate with REST with JSON as a data interchange format. JSON is easy to read and most programming languages can easily parse JSON. The ease of use comes with its cons though. You can't enforce a well defined structure and protocol between the client and server. You can send extra data that the recipient doesn't care about. JSON is also pretty big in terms of size compared to protos. Let's take a look at protos and how it can solve some of those issues."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"What Does a Protobuf look like?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There are different versions of proto in GRPC, but I'll be referencing "},{"type":"element","tagName":"a","properties":{"href":"https://developers.google.com/protocol-buffers/docs/proto"},"children":[{"type":"text","value":"proto3"}]},{"type":"text","value":" which is the newest version."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"syntax = \"proto3\";\n\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 result_per_page = 3;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A typical proto looks like this. Each field has a type (string), a field name (query), and a unique field number (1). The field number is used to figure out how to encode the field and its location."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Protos Establish a Schema"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"As you saw in the example earlier, the proto defined a schema of a SearchRequest. Having a schema is important because it guarantees type-safety and prevents schema-violations. The best part of protos is that you can have a server implementation in one language and a client in a different language and the proto can be consumed without any difficulty."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In GRPC, you can also define services which are like REST endpoints. Let's expand on the example from above."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"syntax = \"proto3\";\n\nservice SearchService {\n  rpc Search (SearchRequest) returns (SearchResponse);\n}\n\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 result_per_page = 3;\n}\n\nmessage SearchResponse {\n  string response = 1;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let's say we have a Go server that implements "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"SearchService"}]},{"type":"text","value":". The implementation will look something like."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"type searchServer struct {}\n\nfunc (s *searchServer) Search(ctx context.Context, req *pb.SearchRequest) (*pb.SearchResponse, error) {\n  // TODO: Implement the Server\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A Javascript Client can the server like so"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"const service = new SearchServiceClient('http://localhost:8080');\n\nconst req = new SearchRequest();\nreq.setQuery(\"AnimalCrossing\");\nreq.setPageNumber(3);\nreq.setResultsPerPage(100);\n\nservice.search(req, {}, (err, resp) => {});\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"An equivalent client in REST would look like so: "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"const data = {\n    query: \"AnimalCrossing\",\n  pageNumber: 3,\n  resultsPerPage: 100,\n};\n\nfetch(\"/search\", data);\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The problem with the 2nd approach is that you cannot guarentee any type safety or check for required fields without extra business logic. You can also set a field incorrectly like using "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"page_number"}]},{"type":"text","value":" instead of "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"pageNumber"}]},{"type":"text","value":". I also think the RPC version is much more readable. You can tell exactly what the data is by reading the object name."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"REST based APIs do not have schema out of the box. If you want to give your REST API a schema, you'll need to use something like "},{"type":"element","tagName":"a","properties":{"href":"http://json-schema.org/"},"children":[{"type":"text","value":"JSON Schema"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Network Requests Transmit Less Bytes"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let's see how SearchRequest might look like in JSON vs proto. Let's say the client sets query to \"animal crossing\", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"page_number"}]},{"type":"text","value":" to 3, and "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"result_per_page"}]},{"type":"text","value":" to 100. Once this proto is populated and serialized, it will look something like this "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"[\"animal crossing\",3,100]"}]},{"type":"text","value":". In JSON, you'll represent the same object like so:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"{\n    \"query\": \"animal crossing\",\n    \"page_number\": 3,\n    \"result_per_page\": 100\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"You can already tell the serialized proto version requires less characters to represent than the equivalent in JSON. This is really good for companies that need to shave as much data off each request/response to make network requests as small as possible. The only issue is the serialized proto is not easy for a human being to read."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Protos Can Be Used In a Plethora of Programming Languages"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Just like REST, RPCs and protos can be consumed by any programming language. Here's some tutorials from Google on how to set up "},{"type":"element","tagName":"a","properties":{"href":"https://developers.google.com/protocol-buffers/docs/tutorials"},"children":[{"type":"text","value":"protos"}]},{"type":"text","value":". There are also open source projects to set up protos for other programming languages like "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/protobufjs/protobuf.js"},"children":[{"type":"text","value":"protobuf.js"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Conclusion"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In conclusion, I'm a big fan of how RPCs define a clear and well defined schema and transmits less bytes over the wire. I also think using protos help increase the readability of the code since everything is typed and objects are initialized with the proto object. Have you used RPCs before? Do you prefer that over REST? Let me know in the comments section below."}]}],"data":{"quirksMode":false}},"id":"8ba586a3-a185-50f4-bcb0-998e1f326e34","excerpt":"Most modern services and clients communicate with REST with JSON as a data interchange format. JSON is easy to read and most programmingâ€¦","frontmatter":{"author":"awang","date":"July 25, 2020","modified_date":"July 30, 2020","slug":"why-use-remote-procedure-calls-RPC-over-JSON-fbb4ae56","title":"Why Remote Procedure Calls (RPC) Are Better than REST","tags":["programming","coding","website","rpc","json","computer science"],"cover_photo":"/blogImages/grpc/cover.jpg?width=400&height=400&isResponsive=true&supportsWebp=true","related_tag":"coding","is_travel_blog":null,"has_affiliate_links":null,"is_review":null,"brand_name":null,"item_name":null,"review_description":null,"score":null},"wordCount":{"words":579},"fields":{"readingTime":{"text":"4 min read"}}},"relatedPosts":{"edges":[{"node":{"frontmatter":{"slug":"how-make-your-website-accessible-e77547a0","title":"How to make your website accessible","cover_photo":"/blogImages/accessibility/cover.jpg?width=740&height=453&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"ultimate-guide-coding-on-chromebook-bb405513","title":"Setting Up Java, Python, Node, React, and Angular on a Chromebook","cover_photo":"/blogImages/chromebook_coding/cover-2.jpg?width=1742&height=1306&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"coding-on-an-ipad-190ccc96","title":"Coding on an iPad","cover_photo":"/blogImages/code_on_ipad/cover.jpg?width=1024&height=715&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"blog/client-side-rendered-crawler-e08c0320","title":"Building an Instagram Crawler Using Node and Puppeteer","cover_photo":"/blogImages/crawler/cover.jpg?width=692&height=496&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"difference-between-studying-computer-science-working-software-engineer-df3bb680","title":"Programming in School vs Working as a Software Engineer","cover_photo":"/blogImages/school_vs_work/cover.jpg?width=1676&height=1257&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"how-to-host-a-website-for-free-5165ea28","title":"How to host a website for free","cover_photo":"/blogImages/free_website/cover.jpg?width=874&height=667&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"blog/landing-first-software-engineering-job-b7d3d6a2","title":"3 Simple Steps to Land Software Engineering Interviews During the Pandemic (ft. New Grads)","cover_photo":"/blogImages/landing_first_software_job/fang.jpg?width=1181&height=1181&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"android-development-on-chromebook-2020-5734ed1a","title":"How to Develop Android Apps on a Chromebook in 2020","cover_photo":"/blogImages/mobile_dev_on_chromebook/cover.jpg?width=2400&height=1600&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"recommended-chromebooks-for-programming-2020-5734ed1a","title":"The Best Chromebooks for Programming in 2020","cover_photo":"/blogImages/recommended_chromebooks/acer_chromebook_spin.jpg?width=960&height=631&isResponsive=true&supportsWebp=true"}}},{"node":{"frontmatter":{"slug":"blog/optimizing-website-performance-improve-seo-384b1f1b","title":"Optimizing Website Performance to Improve SEO Rank","cover_photo":"/blogImages/seo_performance/cover.jpg?width=736&height=686&isResponsive=true&supportsWebp=true"}}}]}},"pageContext":{"slug":"why-use-remote-procedure-calls-RPC-over-JSON-fbb4ae56","relatedTag":"coding"}}}